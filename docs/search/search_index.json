{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Polymera Work in progress! Polymera is a Python package for representing ambiguous sequences. An ambiguous sequence has a number of multiple possible letters (symbols, elements) at each position. Additionally, Polymera can model sequences written with complement alphabets. Each letter of a complement alphabet can form a pair with specific letters, their complements. These sequences can describe linear polymers, for example DNA, that can pair with a complement polymer. Polymera is a genus of crane fly. Details The Polymer class consists of the Sequence and the Alphabet classes. The relations between the letters are described by the alphabet, and can be complement relations or other type. Polymera has built-in alphabets for nucleic acids (DNA) and proteins. Representation in writing Representation of these sequences in writing can be in the following way: AGXCTGXGTGTA55GTAGT66 . The sequence can contain an arbitrary set of letters. For example, in the case of DNA, it can represent xenonucleotides or methylated nucleotides. Sequence with choice ambiguity: GCG|A,G|TC,GG , where a segment separator character, here | (vertical bar), denotes the sections of the sequence, and the choices are separated by another character: here we use , (comma). The above can mean one of 4 (=1*2*2) strings: GCGATC GCGAGG GCGGTC GCGGGG The choices can span multiple positions with multiletter choices ( GCG|ATC,AGA|TC,GT|AGCA ) and can contain deletions (indels), marked with - : GTAGTG|AT,-T|TAA . Note that |AATCCGTCAA| does not equal to |AA|TCCGTC|AA| because the segment boundaries specify the full subsequence that has to exist together in the sequence. Finally, the letters can be written with multiple characters, using a separator character between the letters ( . ): A,6mA|T.G.C.T|5mC,C|G.C.5mC . This is useful if we want to represent similarities between some letters in a readable way. In the example above, A = adenine, 6mA = N6-methyladenine, 5mC = C5-methylcytosine. Another example is writing diphthongs, for example ae . Information content Note that in a sequence, an ambiguous position can mean one of two things: Options: all letters noted in the position are suitable. Uncertainty: it's not exactly known what letter occupies the position. This has implications for the information content of the sequence. Install pip install polymera Usage Define a sequence: sequence = polymera . Sequence () sequence . add_sequence_from_string ( \"ATGAA,ATGCC|TATATTAGAAAAAA\" ) sequence . calculate_number_of_combinations () Returns 2 . Instantiate polymer: polymer = polymera . Polymer ( sequence , alphabet = polymera . bio . DNAAlphabet ) polymer . get_sequence_reverse_complement () . to_string () Returns TTTTTTCTAATATA|GGCAT,TTCAT Versioning Polymera uses the semantic versioning scheme. License = MIT Polymera is free software , which means the users have the freedom to run, copy, distribute, study, change and improve the software. Polymera was written at the Edinburgh Genome Foundry by Peter Vegh and is released under the MIT license.","title":"Home"},{"location":"#polymera","text":"Work in progress! Polymera is a Python package for representing ambiguous sequences. An ambiguous sequence has a number of multiple possible letters (symbols, elements) at each position. Additionally, Polymera can model sequences written with complement alphabets. Each letter of a complement alphabet can form a pair with specific letters, their complements. These sequences can describe linear polymers, for example DNA, that can pair with a complement polymer. Polymera is a genus of crane fly.","title":"Polymera"},{"location":"#details","text":"The Polymer class consists of the Sequence and the Alphabet classes. The relations between the letters are described by the alphabet, and can be complement relations or other type. Polymera has built-in alphabets for nucleic acids (DNA) and proteins.","title":"Details"},{"location":"#representation-in-writing","text":"Representation of these sequences in writing can be in the following way: AGXCTGXGTGTA55GTAGT66 . The sequence can contain an arbitrary set of letters. For example, in the case of DNA, it can represent xenonucleotides or methylated nucleotides. Sequence with choice ambiguity: GCG|A,G|TC,GG , where a segment separator character, here | (vertical bar), denotes the sections of the sequence, and the choices are separated by another character: here we use , (comma). The above can mean one of 4 (=1*2*2) strings: GCGATC GCGAGG GCGGTC GCGGGG The choices can span multiple positions with multiletter choices ( GCG|ATC,AGA|TC,GT|AGCA ) and can contain deletions (indels), marked with - : GTAGTG|AT,-T|TAA . Note that |AATCCGTCAA| does not equal to |AA|TCCGTC|AA| because the segment boundaries specify the full subsequence that has to exist together in the sequence. Finally, the letters can be written with multiple characters, using a separator character between the letters ( . ): A,6mA|T.G.C.T|5mC,C|G.C.5mC . This is useful if we want to represent similarities between some letters in a readable way. In the example above, A = adenine, 6mA = N6-methyladenine, 5mC = C5-methylcytosine. Another example is writing diphthongs, for example ae .","title":"Representation in writing"},{"location":"#information-content","text":"Note that in a sequence, an ambiguous position can mean one of two things: Options: all letters noted in the position are suitable. Uncertainty: it's not exactly known what letter occupies the position. This has implications for the information content of the sequence.","title":"Information content"},{"location":"#install","text":"pip install polymera","title":"Install"},{"location":"#usage","text":"Define a sequence: sequence = polymera . Sequence () sequence . add_sequence_from_string ( \"ATGAA,ATGCC|TATATTAGAAAAAA\" ) sequence . calculate_number_of_combinations () Returns 2 . Instantiate polymer: polymer = polymera . Polymer ( sequence , alphabet = polymera . bio . DNAAlphabet ) polymer . get_sequence_reverse_complement () . to_string () Returns TTTTTTCTAATATA|GGCAT,TTCAT","title":"Usage"},{"location":"#versioning","text":"Polymera uses the semantic versioning scheme.","title":"Versioning"},{"location":"#license-mit","text":"Polymera is free software , which means the users have the freedom to run, copy, distribute, study, change and improve the software. Polymera was written at the Edinburgh Genome Foundry by Peter Vegh and is released under the MIT license.","title":"License = MIT"},{"location":"reference/polymera/","text":"Module polymera View Source from .polymera import Polymer , Alphabet , Sequence , Segment from .bio import dna from .version import __version__ Sub-modules polymera.bio polymera.polymera polymera.version","title":"Index"},{"location":"reference/polymera/#module-polymera","text":"View Source from .polymera import Polymer , Alphabet , Sequence , Segment from .bio import dna from .version import __version__","title":"Module polymera"},{"location":"reference/polymera/#sub-modules","text":"polymera.bio polymera.polymera polymera.version","title":"Sub-modules"},{"location":"reference/polymera/polymera/","text":"Module polymera.polymera View Source class Polymer : \"\"\"Class for representing a sequence with its alphabet. **Parameters** **sequence** > `Sequence` class instance. **alphabet** > `Alphabet` class instance. \"\"\" def __ init__ ( self , sequence , alphabet ) : self . sequence = sequence self . alphabet = alphabet def get_choice_complement ( self , seq ) : \"\"\"Return the complement of a sequence string (choice). **Parameters** **seq** > String to complement (`str`). \"\"\" # The complements of a letter are always a list and the first one is used : complement = \"\" . join ([ self . alphabet . complements [ letter ][ 0 ] for letter in seq ]) return complement def get_segment_complement ( self , segment ) : \"\"\"Return the complement of a Segment. **Parameters** **segment** > `Segment` to complement. \"\"\" complement_choices = [] for choice in segment . choices : complement_choice = self . get_choice_complement ( choice ) complement_choices . append ( complement_choice ) complement_segment = Segment ( complement_choices ) return complement_segment def get_sequence_complement ( self ) : \"\"\"Return the complement of the polymer sequence.\"\"\" complement_segments = [] for segment in self . sequence . segments : complement_segment = self . get_segment_complement ( segment ) complement_segments . append ( complement_segment ) return Sequence ( complement_segments , self . sequence . separators ) def get_choice_reverse ( self , seq ) : \"\"\"Get reverse of a sequence string (choice). **Parameters** **seq** > String to reverse (`str`). \"\"\" reverse = seq [ ::- 1 ] return reverse def get_segment_reverse ( self , segment ) : \"\"\"Return the reverse of a Segment. **Parameters** **segment** > `Segment` to reverse. \"\"\" reverse_choices = [] for choice in reversed ( segment . choices ) : reverse_choice = self . get_choice_reverse ( choice ) reverse_choices . append ( reverse_choice ) reverse_segment = Segment ( reverse_choices ) return reverse_segment def get_sequence_reverse ( self ) : \"\"\"Return the reverse of the polymer sequence.\"\"\" reverse_segments = [] for segment in reversed ( self . sequence . segments ) : reverse_segment = self . get_segment_reverse ( segment ) reverse_segments . append ( reverse_segment ) return Sequence ( reverse_segments , self . sequence . separators ) def get_sequence_reverse_complement ( self ) : \"\"\"Return the reverse complement of the polymer sequence.\"\"\" reverse = self . get_sequence_reverse () reversed_polymer = Polymer ( sequence = reverse , alphabet = self . alphabet ) reverse_complement = reversed_polymer . get_sequence_complement () return reverse_complement class Alphabet : \"\"\"The Alphabet class describes the relations between the letters. **Parameters** **letters** > The `set` of letters (symbols) used for the sequence. **complements** > The `dict` of complement relations. Format: `{\" A \": [\" T \"], \" T \": [\" A \", \" 6 \"]...`. **relations** > Not implemented yet. Non-complement relations between letters. \"\"\" def __ init__ ( self , letters= {}, complements= {}, relations = None , ) : if any ([ len ( letter ) > 1 for letter in letters ]) : raise ValueError ( \"Multicharacter letters are not implemented yet.\" ) self . letters = letters self . complements = complements self . relations = relations class Sequence : \"\"\"The Sequence class stores the sequence (string). **Parameters** **segments** > A `list` of `Segment`s. **separators** > The separator characters in a `dict`. Format: `{\" segment \": \" | \", \" choice \": \" , \", \" letter \": \" . \", \" del \": \" - \"}`. Letter separators are not implemented yet. \"\"\" def __ init__ ( self , segments = None , separators= { \"segment\" : \"|\" , \"choice\" : \",\" , \"letter\" : \".\" , \"del\" : \"-\" }, ) : if segments is None : self . segments = [] else : self . segments = segments self . separators = separators def create_choices_from_string ( self , string ) : choices = string . split ( self . separators [ \"choice\" ]) if not all ([ len ( choice ) == len ( choices [ 0 ]) for choice in choices ]) : raise ValueError ( \"Choices of a segment must have the same length.\" ) return choices def create_segments_from_string ( self , string ) : \"\"\"Create a list of `Segment` instances from the sequence attribute.\"\"\" separator = self . separators [ \"segment\" ] segment_strings = string . split ( separator ) segments = [ Segment ( self . create_choices_from_string ( string )) for string in segment_strings ] return segments def add_sequence_from_string ( self , string ) : \"\"\"Convert a string into segments and append to the sequence. **Parameters** **string** > `str`. \"\"\" if self . segments is [] : self . segments = self . create_segments_from_string ( string ) else : self . segments += self . create_segments_from_string ( string ) def calculate_number_of_combinations ( self ) : \"\"\"Calculate the number of exact sequences represented.\"\"\" multiplier_list = [] for segment in self . segments : multiplier_list . append ( len ( segment . choices )) x = 1 for multiplier in multiplier_list: x *= multiplier return x def to_string ( self ) : \"\"\"Return a string representation of the ambiguous sequence.\"\"\" joined_choices = [ self . separators [ \"choice\" ]. join ( segment . choices ) for segment in self . segments ] string = self . separators [ \"segment\" ]. join ( joined_choices ) return string class Segment : \"\"\"Segments store the possible subsequences (choices) for a given region. **Parameters** **choices** > The `list` of segment choice `str`s. \"\"\" def __ init__ ( self , choices ) : self . choices = choices Classes Alphabet class Alphabet ( letters = {}, complements = {}, relations = None ) The Alphabet class describes the relations between the letters. Parameters letters The set of letters (symbols) used for the sequence. complements The dict of complement relations. Format: {\"A\": [\"T\"], \"T\": [\"A\", \"6\"]... . relations Not implemented yet. Non-complement relations between letters. View Source class Alphabet : \"\"\"The Alphabet class describes the relations between the letters. **Parameters** **letters** > The `set` of letters (symbols) used for the sequence. **complements** > The `dict` of complement relations. Format: `{\" A \": [\" T \"], \" T \": [\" A \", \" 6 \"]...`. **relations** > Not implemented yet. Non-complement relations between letters. \"\"\" def __init__ ( self , letters = {} , complements = {} , relations = None , ): if any ([ len ( letter ) > 1 for letter in letters ]): raise ValueError ( \"Multicharacter letters are not implemented yet.\" ) self . letters = letters self . complements = complements self . relations = relations Polymer class Polymer ( sequence , alphabet ) Class for representing a sequence with its alphabet. Parameters sequence Sequence class instance. alphabet Alphabet class instance. View Source class Polymer : \"\"\"Class for representing a sequence with its alphabet. **Parameters** **sequence** > `Sequence` class instance. **alphabet** > `Alphabet` class instance. \"\"\" def __ init__ ( self , sequence , alphabet ) : self . sequence = sequence self . alphabet = alphabet def get_choice_complement ( self , seq ) : \"\"\"Return the complement of a sequence string (choice). **Parameters** **seq** > String to complement (`str`). \"\"\" # The complements of a letter are always a list and the first one is used : complement = \"\" . join ([ self . alphabet . complements [ letter ][ 0 ] for letter in seq ]) return complement def get_segment_complement ( self , segment ) : \"\"\"Return the complement of a Segment. **Parameters** **segment** > `Segment` to complement. \"\"\" complement_choices = [] for choice in segment . choices : complement_choice = self . get_choice_complement ( choice ) complement_choices . append ( complement_choice ) complement_segment = Segment ( complement_choices ) return complement_segment def get_sequence_complement ( self ) : \"\"\"Return the complement of the polymer sequence.\"\"\" complement_segments = [] for segment in self . sequence . segments : complement_segment = self . get_segment_complement ( segment ) complement_segments . append ( complement_segment ) return Sequence ( complement_segments , self . sequence . separators ) def get_choice_reverse ( self , seq ) : \"\"\"Get reverse of a sequence string (choice). **Parameters** **seq** > String to reverse (`str`). \"\"\" reverse = seq [ ::- 1 ] return reverse def get_segment_reverse ( self , segment ) : \"\"\"Return the reverse of a Segment. **Parameters** **segment** > `Segment` to reverse. \"\"\" reverse_choices = [] for choice in reversed ( segment . choices ) : reverse_choice = self . get_choice_reverse ( choice ) reverse_choices . append ( reverse_choice ) reverse_segment = Segment ( reverse_choices ) return reverse_segment def get_sequence_reverse ( self ) : \"\"\"Return the reverse of the polymer sequence.\"\"\" reverse_segments = [] for segment in reversed ( self . sequence . segments ) : reverse_segment = self . get_segment_reverse ( segment ) reverse_segments . append ( reverse_segment ) return Sequence ( reverse_segments , self . sequence . separators ) def get_sequence_reverse_complement ( self ) : \"\"\"Return the reverse complement of the polymer sequence.\"\"\" reverse = self . get_sequence_reverse () reversed_polymer = Polymer ( sequence = reverse , alphabet = self . alphabet ) reverse_complement = reversed_polymer . get_sequence_complement () return reverse_complement Methods get_choice_complement def get_choice_complement ( self , seq ) Return the complement of a sequence string (choice). Parameters seq String to complement ( str ). View Source def get_choice_complement ( self , seq ): \"\"\"Return the complement of a sequence string (choice). **Parameters** **seq** > String to complement (`str`). \"\"\" # The complements of a letter are always a list and the first one is used: complement = \"\" . join ([ self . alphabet . complements [ letter ][ 0 ] for letter in seq ]) return complement get_choice_reverse def get_choice_reverse ( self , seq ) Get reverse of a sequence string (choice). Parameters seq String to reverse ( str ). View Source def get_choice_reverse ( self , seq ) : \"\"\"Get reverse of a sequence string (choice). **Parameters** **seq** > String to reverse (`str`). \"\"\" reverse = seq [ ::- 1 ] return reverse get_segment_complement def get_segment_complement ( self , segment ) Return the complement of a Segment. Parameters segment Segment to complement. View Source def get_segment_complement ( self , segment ): \"\"\"Return the complement of a Segment. **Parameters** **segment** > `Segment` to complement. \"\"\" complement_choices = [] for choice in segment . choices : complement_choice = self . get_choice_complement ( choice ) complement_choices . append ( complement_choice ) complement_segment = Segment ( complement_choices ) return complement_segment get_segment_reverse def get_segment_reverse ( self , segment ) Return the reverse of a Segment. Parameters segment Segment to reverse. View Source def get_segment_reverse ( self , segment ): \"\"\"Return the reverse of a Segment. **Parameters** **segment** > `Segment` to reverse. \"\"\" reverse_choices = [] for choice in reversed ( segment . choices ): reverse_choice = self . get_choice_reverse ( choice ) reverse_choices . append ( reverse_choice ) reverse_segment = Segment ( reverse_choices ) return reverse_segment get_sequence_complement def get_sequence_complement ( self ) Return the complement of the polymer sequence. View Source def get_sequence_complement ( self ): \"\"\"Return the complement of the polymer sequence.\"\"\" complement_segments = [] for segment in self . sequence . segments : complement_segment = self . get_segment_complement ( segment ) complement_segments . append ( complement_segment ) return Sequence ( complement_segments , self . sequence . separators ) get_sequence_reverse def get_sequence_reverse ( self ) Return the reverse of the polymer sequence. View Source def get_sequence_reverse ( self ): \"\"\"Return the reverse of the polymer sequence.\"\"\" reverse_segments = [] for segment in reversed ( self . sequence . segments ): reverse_segment = self . get_segment_reverse ( segment ) reverse_segments . append ( reverse_segment ) return Sequence ( reverse_segments , self . sequence . separators ) get_sequence_reverse_complement def get_sequence_reverse_complement ( self ) Return the reverse complement of the polymer sequence. View Source def get_sequence_reverse_complement ( self ): \"\"\"Return the reverse complement of the polymer sequence.\"\"\" reverse = self . get_sequence_reverse () reversed_polymer = Polymer ( sequence = reverse , alphabet = self . alphabet ) reverse_complement = reversed_polymer . get_sequence_complement () return reverse_complement Segment class Segment ( choices ) Segments store the possible subsequences (choices) for a given region. Parameters choices The list of segment choice str s. View Source class Segment : \"\"\"Segments store the possible subsequences (choices) for a given region. **Parameters** **choices** > The `list` of segment choice `str`s. \"\"\" def __init__ ( self , choices ): self . choices = choices Sequence class Sequence ( segments = None , separators = { 'segment' : '|' , 'choice' : ',' , 'letter' : '.' , 'del' : '-' } ) The Sequence class stores the sequence (string). Parameters segments A list of Segment s. separators The separator characters in a dict . Format: {\"segment\": \"|\", \"choice\": \",\", \"letter\": \".\", \"del\": \"-\"} . Letter separators are not implemented yet. View Source class Sequence : \"\"\"The Sequence class stores the sequence (string). **Parameters** **segments** > A `list` of `Segment`s. **separators** > The separator characters in a `dict`. Format: `{\" segment \": \" | \", \" choice \": \" , \", \" letter \": \" . \", \" del \": \" - \"}`. Letter separators are not implemented yet. \"\"\" def __init__ ( self , segments = None , separators = { \"segment\" : \"|\" , \"choice\" : \",\" , \"letter\" : \".\" , \"del\" : \"-\" } , ): if segments is None : self . segments = [] else : self . segments = segments self . separators = separators def create_choices_from_string ( self , string ): choices = string . split ( self . separators [ \"choice\" ]) if not all ([ len ( choice ) == len ( choices [ 0 ]) for choice in choices ]): raise ValueError ( \"Choices of a segment must have the same length.\" ) return choices def create_segments_from_string ( self , string ): \"\"\"Create a list of `Segment` instances from the sequence attribute.\"\"\" separator = self . separators [ \"segment\" ] segment_strings = string . split ( separator ) segments = [ Segment ( self . create_choices_from_string ( string )) for string in segment_strings ] return segments def add_sequence_from_string ( self , string ): \"\"\"Convert a string into segments and append to the sequence. **Parameters** **string** > `str`. \"\"\" if self . segments is []: self . segments = self . create_segments_from_string ( string ) else : self . segments += self . create_segments_from_string ( string ) def calculate_number_of_combinations ( self ): \"\"\"Calculate the number of exact sequences represented.\"\"\" multiplier_list = [] for segment in self . segments : multiplier_list . append ( len ( segment . choices )) x = 1 for multiplier in multiplier_list : x *= multiplier return x def to_string ( self ): \"\"\"Return a string representation of the ambiguous sequence.\"\"\" joined_choices = [ self . separators [ \"choice\" ]. join ( segment . choices ) for segment in self . segments ] string = self . separators [ \"segment\" ]. join ( joined_choices ) return string Methods add_sequence_from_string def add_sequence_from_string ( self , string ) Convert a string into segments and append to the sequence. Parameters string str . View Source def add_sequence_from_string ( self , string ): \"\"\"Convert a string into segments and append to the sequence. **Parameters** **string** > `str`. \"\"\" if self . segments is []: self . segments = self . create_segments_from_string ( string ) else : self . segments += self . create_segments_from_string ( string ) calculate_number_of_combinations def calculate_number_of_combinations ( self ) Calculate the number of exact sequences represented. View Source def calculate_number_of_combinations ( self ): \"\"\"Calculate the number of exact sequences represented.\"\"\" multiplier_list = [] for segment in self . segments : multiplier_list . append ( len ( segment . choices )) x = 1 for multiplier in multiplier_list : x *= multiplier return x create_choices_from_string def create_choices_from_string ( self , string ) View Source def create_choices_from_string ( self , string ): choices = string . split ( self . separators [ \"choice\" ]) if not all ([ len ( choice ) == len ( choices [ 0 ]) for choice in choices ]): raise ValueError ( \"Choices of a segment must have the same length.\" ) return choices create_segments_from_string def create_segments_from_string ( self , string ) Create a list of Segment instances from the sequence attribute. View Source def create_segments_from_string ( self , string ): \"\"\"Create a list of `Segment` instances from the sequence attribute.\"\"\" separator = self . separators [ \"segment\" ] segment_strings = string . split ( separator ) segments = [ Segment ( self . create_choices_from_string ( string )) for string in segment_strings ] return segments to_string def to_string ( self ) Return a string representation of the ambiguous sequence. View Source def to_string ( self ): \"\"\"Return a string representation of the ambiguous sequence.\"\"\" joined_choices = [ self . separators [ \"choice\" ]. join ( segment . choices ) for segment in self . segments ] string = self . separators [ \"segment\" ]. join ( joined_choices ) return string","title":"Polymera"},{"location":"reference/polymera/polymera/#module-polymerapolymera","text":"View Source class Polymer : \"\"\"Class for representing a sequence with its alphabet. **Parameters** **sequence** > `Sequence` class instance. **alphabet** > `Alphabet` class instance. \"\"\" def __ init__ ( self , sequence , alphabet ) : self . sequence = sequence self . alphabet = alphabet def get_choice_complement ( self , seq ) : \"\"\"Return the complement of a sequence string (choice). **Parameters** **seq** > String to complement (`str`). \"\"\" # The complements of a letter are always a list and the first one is used : complement = \"\" . join ([ self . alphabet . complements [ letter ][ 0 ] for letter in seq ]) return complement def get_segment_complement ( self , segment ) : \"\"\"Return the complement of a Segment. **Parameters** **segment** > `Segment` to complement. \"\"\" complement_choices = [] for choice in segment . choices : complement_choice = self . get_choice_complement ( choice ) complement_choices . append ( complement_choice ) complement_segment = Segment ( complement_choices ) return complement_segment def get_sequence_complement ( self ) : \"\"\"Return the complement of the polymer sequence.\"\"\" complement_segments = [] for segment in self . sequence . segments : complement_segment = self . get_segment_complement ( segment ) complement_segments . append ( complement_segment ) return Sequence ( complement_segments , self . sequence . separators ) def get_choice_reverse ( self , seq ) : \"\"\"Get reverse of a sequence string (choice). **Parameters** **seq** > String to reverse (`str`). \"\"\" reverse = seq [ ::- 1 ] return reverse def get_segment_reverse ( self , segment ) : \"\"\"Return the reverse of a Segment. **Parameters** **segment** > `Segment` to reverse. \"\"\" reverse_choices = [] for choice in reversed ( segment . choices ) : reverse_choice = self . get_choice_reverse ( choice ) reverse_choices . append ( reverse_choice ) reverse_segment = Segment ( reverse_choices ) return reverse_segment def get_sequence_reverse ( self ) : \"\"\"Return the reverse of the polymer sequence.\"\"\" reverse_segments = [] for segment in reversed ( self . sequence . segments ) : reverse_segment = self . get_segment_reverse ( segment ) reverse_segments . append ( reverse_segment ) return Sequence ( reverse_segments , self . sequence . separators ) def get_sequence_reverse_complement ( self ) : \"\"\"Return the reverse complement of the polymer sequence.\"\"\" reverse = self . get_sequence_reverse () reversed_polymer = Polymer ( sequence = reverse , alphabet = self . alphabet ) reverse_complement = reversed_polymer . get_sequence_complement () return reverse_complement class Alphabet : \"\"\"The Alphabet class describes the relations between the letters. **Parameters** **letters** > The `set` of letters (symbols) used for the sequence. **complements** > The `dict` of complement relations. Format: `{\" A \": [\" T \"], \" T \": [\" A \", \" 6 \"]...`. **relations** > Not implemented yet. Non-complement relations between letters. \"\"\" def __ init__ ( self , letters= {}, complements= {}, relations = None , ) : if any ([ len ( letter ) > 1 for letter in letters ]) : raise ValueError ( \"Multicharacter letters are not implemented yet.\" ) self . letters = letters self . complements = complements self . relations = relations class Sequence : \"\"\"The Sequence class stores the sequence (string). **Parameters** **segments** > A `list` of `Segment`s. **separators** > The separator characters in a `dict`. Format: `{\" segment \": \" | \", \" choice \": \" , \", \" letter \": \" . \", \" del \": \" - \"}`. Letter separators are not implemented yet. \"\"\" def __ init__ ( self , segments = None , separators= { \"segment\" : \"|\" , \"choice\" : \",\" , \"letter\" : \".\" , \"del\" : \"-\" }, ) : if segments is None : self . segments = [] else : self . segments = segments self . separators = separators def create_choices_from_string ( self , string ) : choices = string . split ( self . separators [ \"choice\" ]) if not all ([ len ( choice ) == len ( choices [ 0 ]) for choice in choices ]) : raise ValueError ( \"Choices of a segment must have the same length.\" ) return choices def create_segments_from_string ( self , string ) : \"\"\"Create a list of `Segment` instances from the sequence attribute.\"\"\" separator = self . separators [ \"segment\" ] segment_strings = string . split ( separator ) segments = [ Segment ( self . create_choices_from_string ( string )) for string in segment_strings ] return segments def add_sequence_from_string ( self , string ) : \"\"\"Convert a string into segments and append to the sequence. **Parameters** **string** > `str`. \"\"\" if self . segments is [] : self . segments = self . create_segments_from_string ( string ) else : self . segments += self . create_segments_from_string ( string ) def calculate_number_of_combinations ( self ) : \"\"\"Calculate the number of exact sequences represented.\"\"\" multiplier_list = [] for segment in self . segments : multiplier_list . append ( len ( segment . choices )) x = 1 for multiplier in multiplier_list: x *= multiplier return x def to_string ( self ) : \"\"\"Return a string representation of the ambiguous sequence.\"\"\" joined_choices = [ self . separators [ \"choice\" ]. join ( segment . choices ) for segment in self . segments ] string = self . separators [ \"segment\" ]. join ( joined_choices ) return string class Segment : \"\"\"Segments store the possible subsequences (choices) for a given region. **Parameters** **choices** > The `list` of segment choice `str`s. \"\"\" def __ init__ ( self , choices ) : self . choices = choices","title":"Module polymera.polymera"},{"location":"reference/polymera/polymera/#classes","text":"","title":"Classes"},{"location":"reference/polymera/polymera/#alphabet","text":"class Alphabet ( letters = {}, complements = {}, relations = None ) The Alphabet class describes the relations between the letters. Parameters letters The set of letters (symbols) used for the sequence. complements The dict of complement relations. Format: {\"A\": [\"T\"], \"T\": [\"A\", \"6\"]... . relations Not implemented yet. Non-complement relations between letters. View Source class Alphabet : \"\"\"The Alphabet class describes the relations between the letters. **Parameters** **letters** > The `set` of letters (symbols) used for the sequence. **complements** > The `dict` of complement relations. Format: `{\" A \": [\" T \"], \" T \": [\" A \", \" 6 \"]...`. **relations** > Not implemented yet. Non-complement relations between letters. \"\"\" def __init__ ( self , letters = {} , complements = {} , relations = None , ): if any ([ len ( letter ) > 1 for letter in letters ]): raise ValueError ( \"Multicharacter letters are not implemented yet.\" ) self . letters = letters self . complements = complements self . relations = relations","title":"Alphabet"},{"location":"reference/polymera/polymera/#polymer","text":"class Polymer ( sequence , alphabet ) Class for representing a sequence with its alphabet. Parameters sequence Sequence class instance. alphabet Alphabet class instance. View Source class Polymer : \"\"\"Class for representing a sequence with its alphabet. **Parameters** **sequence** > `Sequence` class instance. **alphabet** > `Alphabet` class instance. \"\"\" def __ init__ ( self , sequence , alphabet ) : self . sequence = sequence self . alphabet = alphabet def get_choice_complement ( self , seq ) : \"\"\"Return the complement of a sequence string (choice). **Parameters** **seq** > String to complement (`str`). \"\"\" # The complements of a letter are always a list and the first one is used : complement = \"\" . join ([ self . alphabet . complements [ letter ][ 0 ] for letter in seq ]) return complement def get_segment_complement ( self , segment ) : \"\"\"Return the complement of a Segment. **Parameters** **segment** > `Segment` to complement. \"\"\" complement_choices = [] for choice in segment . choices : complement_choice = self . get_choice_complement ( choice ) complement_choices . append ( complement_choice ) complement_segment = Segment ( complement_choices ) return complement_segment def get_sequence_complement ( self ) : \"\"\"Return the complement of the polymer sequence.\"\"\" complement_segments = [] for segment in self . sequence . segments : complement_segment = self . get_segment_complement ( segment ) complement_segments . append ( complement_segment ) return Sequence ( complement_segments , self . sequence . separators ) def get_choice_reverse ( self , seq ) : \"\"\"Get reverse of a sequence string (choice). **Parameters** **seq** > String to reverse (`str`). \"\"\" reverse = seq [ ::- 1 ] return reverse def get_segment_reverse ( self , segment ) : \"\"\"Return the reverse of a Segment. **Parameters** **segment** > `Segment` to reverse. \"\"\" reverse_choices = [] for choice in reversed ( segment . choices ) : reverse_choice = self . get_choice_reverse ( choice ) reverse_choices . append ( reverse_choice ) reverse_segment = Segment ( reverse_choices ) return reverse_segment def get_sequence_reverse ( self ) : \"\"\"Return the reverse of the polymer sequence.\"\"\" reverse_segments = [] for segment in reversed ( self . sequence . segments ) : reverse_segment = self . get_segment_reverse ( segment ) reverse_segments . append ( reverse_segment ) return Sequence ( reverse_segments , self . sequence . separators ) def get_sequence_reverse_complement ( self ) : \"\"\"Return the reverse complement of the polymer sequence.\"\"\" reverse = self . get_sequence_reverse () reversed_polymer = Polymer ( sequence = reverse , alphabet = self . alphabet ) reverse_complement = reversed_polymer . get_sequence_complement () return reverse_complement","title":"Polymer"},{"location":"reference/polymera/polymera/#methods","text":"","title":"Methods"},{"location":"reference/polymera/polymera/#get_choice_complement","text":"def get_choice_complement ( self , seq ) Return the complement of a sequence string (choice). Parameters seq String to complement ( str ). View Source def get_choice_complement ( self , seq ): \"\"\"Return the complement of a sequence string (choice). **Parameters** **seq** > String to complement (`str`). \"\"\" # The complements of a letter are always a list and the first one is used: complement = \"\" . join ([ self . alphabet . complements [ letter ][ 0 ] for letter in seq ]) return complement","title":"get_choice_complement"},{"location":"reference/polymera/polymera/#get_choice_reverse","text":"def get_choice_reverse ( self , seq ) Get reverse of a sequence string (choice). Parameters seq String to reverse ( str ). View Source def get_choice_reverse ( self , seq ) : \"\"\"Get reverse of a sequence string (choice). **Parameters** **seq** > String to reverse (`str`). \"\"\" reverse = seq [ ::- 1 ] return reverse","title":"get_choice_reverse"},{"location":"reference/polymera/polymera/#get_segment_complement","text":"def get_segment_complement ( self , segment ) Return the complement of a Segment. Parameters segment Segment to complement. View Source def get_segment_complement ( self , segment ): \"\"\"Return the complement of a Segment. **Parameters** **segment** > `Segment` to complement. \"\"\" complement_choices = [] for choice in segment . choices : complement_choice = self . get_choice_complement ( choice ) complement_choices . append ( complement_choice ) complement_segment = Segment ( complement_choices ) return complement_segment","title":"get_segment_complement"},{"location":"reference/polymera/polymera/#get_segment_reverse","text":"def get_segment_reverse ( self , segment ) Return the reverse of a Segment. Parameters segment Segment to reverse. View Source def get_segment_reverse ( self , segment ): \"\"\"Return the reverse of a Segment. **Parameters** **segment** > `Segment` to reverse. \"\"\" reverse_choices = [] for choice in reversed ( segment . choices ): reverse_choice = self . get_choice_reverse ( choice ) reverse_choices . append ( reverse_choice ) reverse_segment = Segment ( reverse_choices ) return reverse_segment","title":"get_segment_reverse"},{"location":"reference/polymera/polymera/#get_sequence_complement","text":"def get_sequence_complement ( self ) Return the complement of the polymer sequence. View Source def get_sequence_complement ( self ): \"\"\"Return the complement of the polymer sequence.\"\"\" complement_segments = [] for segment in self . sequence . segments : complement_segment = self . get_segment_complement ( segment ) complement_segments . append ( complement_segment ) return Sequence ( complement_segments , self . sequence . separators )","title":"get_sequence_complement"},{"location":"reference/polymera/polymera/#get_sequence_reverse","text":"def get_sequence_reverse ( self ) Return the reverse of the polymer sequence. View Source def get_sequence_reverse ( self ): \"\"\"Return the reverse of the polymer sequence.\"\"\" reverse_segments = [] for segment in reversed ( self . sequence . segments ): reverse_segment = self . get_segment_reverse ( segment ) reverse_segments . append ( reverse_segment ) return Sequence ( reverse_segments , self . sequence . separators )","title":"get_sequence_reverse"},{"location":"reference/polymera/polymera/#get_sequence_reverse_complement","text":"def get_sequence_reverse_complement ( self ) Return the reverse complement of the polymer sequence. View Source def get_sequence_reverse_complement ( self ): \"\"\"Return the reverse complement of the polymer sequence.\"\"\" reverse = self . get_sequence_reverse () reversed_polymer = Polymer ( sequence = reverse , alphabet = self . alphabet ) reverse_complement = reversed_polymer . get_sequence_complement () return reverse_complement","title":"get_sequence_reverse_complement"},{"location":"reference/polymera/polymera/#segment","text":"class Segment ( choices ) Segments store the possible subsequences (choices) for a given region. Parameters choices The list of segment choice str s. View Source class Segment : \"\"\"Segments store the possible subsequences (choices) for a given region. **Parameters** **choices** > The `list` of segment choice `str`s. \"\"\" def __init__ ( self , choices ): self . choices = choices","title":"Segment"},{"location":"reference/polymera/polymera/#sequence","text":"class Sequence ( segments = None , separators = { 'segment' : '|' , 'choice' : ',' , 'letter' : '.' , 'del' : '-' } ) The Sequence class stores the sequence (string). Parameters segments A list of Segment s. separators The separator characters in a dict . Format: {\"segment\": \"|\", \"choice\": \",\", \"letter\": \".\", \"del\": \"-\"} . Letter separators are not implemented yet. View Source class Sequence : \"\"\"The Sequence class stores the sequence (string). **Parameters** **segments** > A `list` of `Segment`s. **separators** > The separator characters in a `dict`. Format: `{\" segment \": \" | \", \" choice \": \" , \", \" letter \": \" . \", \" del \": \" - \"}`. Letter separators are not implemented yet. \"\"\" def __init__ ( self , segments = None , separators = { \"segment\" : \"|\" , \"choice\" : \",\" , \"letter\" : \".\" , \"del\" : \"-\" } , ): if segments is None : self . segments = [] else : self . segments = segments self . separators = separators def create_choices_from_string ( self , string ): choices = string . split ( self . separators [ \"choice\" ]) if not all ([ len ( choice ) == len ( choices [ 0 ]) for choice in choices ]): raise ValueError ( \"Choices of a segment must have the same length.\" ) return choices def create_segments_from_string ( self , string ): \"\"\"Create a list of `Segment` instances from the sequence attribute.\"\"\" separator = self . separators [ \"segment\" ] segment_strings = string . split ( separator ) segments = [ Segment ( self . create_choices_from_string ( string )) for string in segment_strings ] return segments def add_sequence_from_string ( self , string ): \"\"\"Convert a string into segments and append to the sequence. **Parameters** **string** > `str`. \"\"\" if self . segments is []: self . segments = self . create_segments_from_string ( string ) else : self . segments += self . create_segments_from_string ( string ) def calculate_number_of_combinations ( self ): \"\"\"Calculate the number of exact sequences represented.\"\"\" multiplier_list = [] for segment in self . segments : multiplier_list . append ( len ( segment . choices )) x = 1 for multiplier in multiplier_list : x *= multiplier return x def to_string ( self ): \"\"\"Return a string representation of the ambiguous sequence.\"\"\" joined_choices = [ self . separators [ \"choice\" ]. join ( segment . choices ) for segment in self . segments ] string = self . separators [ \"segment\" ]. join ( joined_choices ) return string","title":"Sequence"},{"location":"reference/polymera/polymera/#methods_1","text":"","title":"Methods"},{"location":"reference/polymera/polymera/#add_sequence_from_string","text":"def add_sequence_from_string ( self , string ) Convert a string into segments and append to the sequence. Parameters string str . View Source def add_sequence_from_string ( self , string ): \"\"\"Convert a string into segments and append to the sequence. **Parameters** **string** > `str`. \"\"\" if self . segments is []: self . segments = self . create_segments_from_string ( string ) else : self . segments += self . create_segments_from_string ( string )","title":"add_sequence_from_string"},{"location":"reference/polymera/polymera/#calculate_number_of_combinations","text":"def calculate_number_of_combinations ( self ) Calculate the number of exact sequences represented. View Source def calculate_number_of_combinations ( self ): \"\"\"Calculate the number of exact sequences represented.\"\"\" multiplier_list = [] for segment in self . segments : multiplier_list . append ( len ( segment . choices )) x = 1 for multiplier in multiplier_list : x *= multiplier return x","title":"calculate_number_of_combinations"},{"location":"reference/polymera/polymera/#create_choices_from_string","text":"def create_choices_from_string ( self , string ) View Source def create_choices_from_string ( self , string ): choices = string . split ( self . separators [ \"choice\" ]) if not all ([ len ( choice ) == len ( choices [ 0 ]) for choice in choices ]): raise ValueError ( \"Choices of a segment must have the same length.\" ) return choices","title":"create_choices_from_string"},{"location":"reference/polymera/polymera/#create_segments_from_string","text":"def create_segments_from_string ( self , string ) Create a list of Segment instances from the sequence attribute. View Source def create_segments_from_string ( self , string ): \"\"\"Create a list of `Segment` instances from the sequence attribute.\"\"\" separator = self . separators [ \"segment\" ] segment_strings = string . split ( separator ) segments = [ Segment ( self . create_choices_from_string ( string )) for string in segment_strings ] return segments","title":"create_segments_from_string"},{"location":"reference/polymera/polymera/#to_string","text":"def to_string ( self ) Return a string representation of the ambiguous sequence. View Source def to_string ( self ): \"\"\"Return a string representation of the ambiguous sequence.\"\"\" joined_choices = [ self . separators [ \"choice\" ]. join ( segment . choices ) for segment in self . segments ] string = self . separators [ \"segment\" ]. join ( joined_choices ) return string","title":"to_string"},{"location":"reference/polymera/version/","text":"Module polymera.version View Source __version__ = \"0.1.0\"","title":"Version"},{"location":"reference/polymera/version/#module-polymeraversion","text":"View Source __version__ = \"0.1.0\"","title":"Module polymera.version"},{"location":"reference/polymera/bio/","text":"Module polymera.bio View Source from .dna import DNAAlphabet from .protein import ProteinAlphabet Sub-modules polymera.bio.dna polymera.bio.protein","title":"Index"},{"location":"reference/polymera/bio/#module-polymerabio","text":"View Source from .dna import DNAAlphabet from .protein import ProteinAlphabet","title":"Module polymera.bio"},{"location":"reference/polymera/bio/#sub-modules","text":"polymera.bio.dna polymera.bio.protein","title":"Sub-modules"},{"location":"reference/polymera/bio/dna/","text":"Module polymera.bio.dna DNA. A adenine T thymine C cytosine G guanine 4 N4-methylcytosine 5 C5-methylcytosine 6 N6-methyladenine View Source \"\"\"DNA. A adenine T thymine C cytosine G guanine 4 N4-methylcytosine 5 C5-methylcytosine 6 N6-methyladenine \"\"\" from ..polymera import Alphabet DNAAlphabet = Alphabet ( letters = { \"A\" , \"T\" , \"C\" , \"G\" , \"4\" , \"5\" , \"6\" }, complements = { \"A\" : [ \"T\" ], \"T\" : [ \"A\" , \"6\" ], \"C\" : [ \"G\" ], \"G\" : [ \"C\" , \"4\" , \"5\" ], \"4\" : [ \"G\" ], \"5\" : [ \"G\" ], \"6\" : [ \"T\" ], }, relations = None , ) Variables DNAAlphabet","title":"Dna"},{"location":"reference/polymera/bio/dna/#module-polymerabiodna","text":"DNA. A adenine T thymine C cytosine G guanine 4 N4-methylcytosine 5 C5-methylcytosine 6 N6-methyladenine View Source \"\"\"DNA. A adenine T thymine C cytosine G guanine 4 N4-methylcytosine 5 C5-methylcytosine 6 N6-methyladenine \"\"\" from ..polymera import Alphabet DNAAlphabet = Alphabet ( letters = { \"A\" , \"T\" , \"C\" , \"G\" , \"4\" , \"5\" , \"6\" }, complements = { \"A\" : [ \"T\" ], \"T\" : [ \"A\" , \"6\" ], \"C\" : [ \"G\" ], \"G\" : [ \"C\" , \"4\" , \"5\" ], \"4\" : [ \"G\" ], \"5\" : [ \"G\" ], \"6\" : [ \"T\" ], }, relations = None , )","title":"Module polymera.bio.dna"},{"location":"reference/polymera/bio/dna/#variables","text":"DNAAlphabet","title":"Variables"},{"location":"reference/polymera/bio/protein/","text":"Module polymera.bio.protein Protein. View Source \"\"\"Protein.\"\"\" from ..polymera import Alphabet ProteinAlphabet = Alphabet ( letters = { \"*\" , # STOP \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" , \"K\" , \"L\" , \"M\" , \"N\" , \"P\" , \"Q\" , \"R\" , \"S\" , \"T\" , \"V\" , \"W\" , \"X\" , \"Y\" , \"Z\" , }, complements = {}, relations = None , ) Variables ProteinAlphabet","title":"Protein"},{"location":"reference/polymera/bio/protein/#module-polymerabioprotein","text":"Protein. View Source \"\"\"Protein.\"\"\" from ..polymera import Alphabet ProteinAlphabet = Alphabet ( letters = { \"*\" , # STOP \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" , \"K\" , \"L\" , \"M\" , \"N\" , \"P\" , \"Q\" , \"R\" , \"S\" , \"T\" , \"V\" , \"W\" , \"X\" , \"Y\" , \"Z\" , }, complements = {}, relations = None , )","title":"Module polymera.bio.protein"},{"location":"reference/polymera/bio/protein/#variables","text":"ProteinAlphabet","title":"Variables"}]}